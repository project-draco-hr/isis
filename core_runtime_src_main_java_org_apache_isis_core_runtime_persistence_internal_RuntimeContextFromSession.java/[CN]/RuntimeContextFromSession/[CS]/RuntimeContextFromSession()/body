{
  this.authenticationSessionProvider=new AuthenticationSessionProviderAbstract(){
    @Override public AuthenticationSession getAuthenticationSession(){
      return IsisContext.getAuthenticationSession();
    }
  }
;
  this.adapterManager=new AdapterManager(){
    @Override public ObjectAdapter getAdapterFor(    Oid oid){
      return null;
    }
    @Override public ObjectAdapter getAdapterFor(    final Object pojo){
      return getRuntimeAdapterManager().getAdapterFor(pojo);
    }
    @Override public ObjectAdapter adapterFor(    final Object pojo){
      return getRuntimeAdapterManager().adapterFor(pojo);
    }
    @Override public ObjectAdapter adapterFor(    final Object pojo,    final ObjectAdapter ownerAdapter){
      return getRuntimeAdapterManager().adapterFor(pojo,ownerAdapter);
    }
    @Override public ObjectAdapter adapterFor(    final Object pojo,    final ObjectAdapter ownerAdapter,    final OneToManyAssociation collection){
      return getRuntimeAdapterManager().adapterFor(pojo,ownerAdapter,collection);
    }
    @Override public ObjectAdapter mapRecreatedPojo(    Oid oid,    Object recreatedPojo){
      return getRuntimeAdapterManager().mapRecreatedPojo(oid,recreatedPojo);
    }
    @Override public void removeAdapter(    ObjectAdapter adapter){
      getRuntimeAdapterManager().removeAdapter(adapter);
    }
    @Override public ObjectAdapter adapterFor(    TypedOid oid){
      return getRuntimeAdapterManager().adapterFor(oid);
    }
    @Override public ObjectAdapter adapterFor(    TypedOid oid,    ConcurrencyChecking concurrencyChecking){
      return getRuntimeAdapterManager().adapterFor(oid,concurrencyChecking);
    }
    @Override public void injectInto(    Object candidate){
      if (AdapterManagerAware.class.isAssignableFrom(candidate.getClass())) {
        final AdapterManagerAware cast=AdapterManagerAware.class.cast(candidate);
        cast.setAdapterManager(this);
      }
    }
  }
;
  this.objectInstantiator=new ObjectInstantiatorAbstract(){
    @Override public Object instantiate(    final Class<?> cls) throws ObjectInstantiationException {
      return getPersistenceSession().getObjectFactory().instantiate(cls);
    }
  }
;
  this.objectDirtier=new ObjectDirtierAbstract(){
    @Override public void objectChanged(    final ObjectAdapter adapter){
      getPersistenceSession().objectChanged(adapter);
    }
    @Override public void objectChanged(    final Object object){
      new DomainObjectContainerObjectChanged().objectChanged(object);
    }
  }
;
  this.objectPersistor=new ObjectPersistorAbstract(){
    @Override public void makePersistent(    final ObjectAdapter adapter){
      getPersistenceSession().makePersistent(adapter);
    }
    @Override public void remove(    final ObjectAdapter adapter){
      getUpdateNotifier().addDisposedObject(adapter);
      getPersistenceSession().destroyObject(adapter);
    }
  }
;
  this.servicesProvider=new ServicesProviderAbstract(){
    @Override public List<ObjectAdapter> getServices(){
      return getPersistenceSession().getServices();
    }
    @Override public <T>T lookupService(    Class<T> cls){
      return getPersistenceSession().getServicesInjector().lookupService(cls);
    }
  }
;
  this.domainObjectServices=new DomainObjectServicesAbstract(){
    @Override public ObjectAdapter createTransientInstance(    final ObjectSpecification spec){
      return getPersistenceSession().createTransientInstance(spec);
    }
    @Override public ObjectAdapter createViewModelInstance(    ObjectSpecification spec,    String memento){
      return getPersistenceSession().createViewModelInstance(spec,memento);
    }
    @Override public ObjectAdapter existingViewModelInstance(    final Object viewModelPojo){
      return getPersistenceSession().existingViewModelInstance(viewModelPojo);
    }
    @Override public ObjectAdapter createAggregatedInstance(    final ObjectSpecification spec,    final ObjectAdapter parent){
      return getPersistenceSession().createAggregatedInstance(spec,parent);
    }
    @Override public Object lookup(    Bookmark bookmark){
      return new DomainObjectContainerResolve().lookup(bookmark);
    }
    @Override public Bookmark bookmarkFor(    Object domainObject){
      return new DomainObjectContainerResolve().bookmarkFor(domainObject);
    }
    @Override public Bookmark bookmarkFor(    Class<?> cls,    String identifier){
      return new DomainObjectContainerResolve().bookmarkFor(cls,identifier);
    }
    @Override public void resolve(    final Object parent){
      new DomainObjectContainerResolve().resolve(parent);
    }
    @Override public void resolve(    final Object parent,    final Object field){
      new DomainObjectContainerResolve().resolve(parent,field);
    }
    @Override public boolean flush(){
      return getTransactionManager().flushTransaction();
    }
    @Override public void commit(){
      getTransactionManager().endTransaction();
    }
    @Override public void informUser(    final String message){
      getMessageBroker().addMessage(message);
    }
    @Override public void warnUser(    final String message){
      getMessageBroker().addWarning(message);
    }
    @Override public void raiseError(    final String message){
      throw new RecoverableException(message);
    }
    @Override public String getProperty(    final String name){
      return RuntimeContextFromSession.this.getProperty(name);
    }
    @Override public List<String> getPropertyNames(){
      return RuntimeContextFromSession.this.getPropertyNames();
    }
    @Override public void injectServicesInto(    Object domainObject){
      getPersistenceSession().getServicesInjector().injectServicesInto(domainObject);
    }
  }
;
  this.querySubmitter=new QuerySubmitterAbstract(){
    @Override public <T>List<ObjectAdapter> allMatchingQuery(    final Query<T> query){
      final ObjectAdapter instances=getPersistenceSession().findInstances(query,QueryCardinality.MULTIPLE);
      return CollectionFacetUtils.convertToAdapterList(instances);
    }
    @Override public <T>ObjectAdapter firstMatchingQuery(    final Query<T> query){
      final ObjectAdapter instances=getPersistenceSession().findInstances(query,QueryCardinality.SINGLE);
      final List<ObjectAdapter> list=CollectionFacetUtils.convertToAdapterList(instances);
      return list.size() > 0 ? list.get(0) : null;
    }
  }
;
  this.servicesInjector=new ServicesInjector(){
    @Override public void injectServicesInto(    final Object object){
      getPersistenceSession().getServicesInjector().injectServicesInto(object);
    }
    @Override public void injectServicesInto(    List<Object> objects){
      getPersistenceSession().getServicesInjector().injectServicesInto(objects);
    }
    @Override public <T>T lookupService(    Class<T> serviceClass){
      return getPersistenceSession().getServicesInjector().lookupService(serviceClass);
    }
    @Override public <T>List<T> lookupServices(    Class<T> serviceClass){
      return getPersistenceSession().getServicesInjector().lookupServices(serviceClass);
    }
    @Override public void injectInto(    Object candidate){
      if (ServicesInjectorAware.class.isAssignableFrom(candidate.getClass())) {
        final ServicesInjectorAware cast=ServicesInjectorAware.class.cast(candidate);
        cast.setServicesInjector(this);
      }
    }
    @Override public List<Object> getRegisteredServices(){
      return getPersistenceSession().getServicesInjector().getRegisteredServices();
    }
  }
;
  this.localizationProvider=new LocalizationProviderAbstract(){
    @Override public Localization getLocalization(){
      return IsisContext.getLocalization();
    }
  }
;
}
