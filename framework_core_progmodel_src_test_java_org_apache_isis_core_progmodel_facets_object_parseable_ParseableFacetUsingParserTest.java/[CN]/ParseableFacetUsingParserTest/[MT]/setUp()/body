{
  mockFacetHolder=mockery.mock(FacetHolder.class);
  mockDependencyInjector=mockery.mock(DependencyInjector.class);
  mockAdapterManager=mockery.mock(AdapterMap.class);
  mockAuthenticationSessionProvider=mockery.mock(AuthenticationSessionProvider.class);
  mockery.checking(new Expectations(){
{
      never(mockAuthenticationSessionProvider);
      never(mockAdapterManager);
      allowing(mockFacetHolder).containsFacet(ValueFacet.class);
      will(returnValue(Boolean.FALSE));
      allowing(mockDependencyInjector).injectDependenciesInto(with(any(Object.class)));
    }
  }
);
  Parser parser=new Parser<String>(){
    public String parseTextEntry(    Object contextPojo,    String entry){
      if (entry.equals("invalid")) {
        throw new ParsingException();
      }
      if (entry.equals("number")) {
        throw new NumberFormatException();
      }
      if (entry.equals("format")) {
        throw new IllegalFormatWidthException(2);
      }
      return entry.toUpperCase();
    }
    public int typicalLength(){
      return 0;
    }
    public String displayTitleOf(    String object,    Localization localization){
      return null;
    }
    public String displayTitleOf(    String object,    String usingMask){
      return null;
    }
    public String parseableTitleOf(    String existing){
      return null;
    }
  }
;
  parseableFacetUsingParser=new ParseableFacetUsingParser(parser,mockFacetHolder,mockAuthenticationSessionProvider,mockDependencyInjector,mockAdapterManager);
}
