{
  final CommandContext commandContext=getCommandContext();
  final Command command=commandContext.getCommand();
  final InteractionContext interactionContext=getInteractionContext();
  final Interaction interaction=interactionContext.getInteraction();
  final ObjectAdapter resultAdapter;
  if (command.getExecutor() == Command.Executor.USER && command.getExecuteIn() == org.apache.isis.applib.annotation.Command.ExecuteIn.BACKGROUND) {
    final CommandService commandService=getCommandService();
    if (!commandService.persistIfPossible(command)) {
      throw new IsisException("Unable to schedule action '" + owningAction.getIdentifier().toClassAndNameIdentityString() + "' to run in background: "+ "CommandService does not support persistent commands ");
    }
    resultAdapter=getAdapterManager().adapterFor(command);
  }
 else {
    interaction.execute(new Callable<Object>(){
      @Override public Object call(){
        try {
          final Object resultPojo=invokeMethodElseFromCache(targetAdapter,arguments);
          if (LOG.isDebugEnabled()) {
            LOG.debug(" action result " + resultPojo);
          }
          ObjectAdapter resultAdapter=cloneIfViewModelCloneable(resultPojo,targetAdapter);
          return resultAdapter != null ? resultAdapter.getObject() : null;
        }
 catch (        InvocationTargetException|IllegalAccessException e) {
          throw new RuntimeException(e);
        }
      }
    }
,getIdentified().getIdentifier().toFullIdentityString(),getClockService(),command);
    final Interaction.Execution priorExecution=interaction.getPriorExecution();
    final RuntimeException executionExceptionIfAny=priorExecution.getException();
    if (executionExceptionIfAny != null) {
      throw executionExceptionIfAny;
    }
    resultAdapter=getAdapterManager().adapterFor(priorExecution.getResult());
    setCommandResultIfEntity(command,resultAdapter);
    captureCurrentInvocationForPublishing(owningAction,targetAdapter,arguments,command,resultAdapter);
  }
  return resultAdapter;
}
