{
  final CommandContext commandContext=getCommandContext();
  final Command command=commandContext.getCommand();
  final InteractionContext interactionContext=getInteractionContext();
  final Interaction interaction=interactionContext.getInteraction();
  final ObjectAdapter resultAdapter;
  if (command.getExecutor() == Command.Executor.USER && command.getExecuteIn() == org.apache.isis.applib.annotation.Command.ExecuteIn.BACKGROUND) {
    final CommandService commandService=getCommandService();
    if (!commandService.persistIfPossible(command)) {
      throw new IsisException(String.format("Unable to schedule action '%s' to run in background; CommandService does not support persistent commands ",owningAction.getIdentifier().toClassAndNameIdentityString()));
    }
    resultAdapter=getAdapterManager().adapterFor(command);
  }
 else {
    final Object target=ObjectAdapter.Util.unwrap(targetAdapter);
    final List<Object> arguments=ObjectAdapter.Util.unwrap(Arrays.asList(argumentAdapters));
    final Interaction.ActionArgs actionArgs=new Interaction.ActionArgs(command,target,arguments);
    final Interaction.MemberCallable callable=new Interaction.MemberCallable<Interaction.ActionArgs>(){
      @Override public Object call(      final Interaction.ActionArgs actionArgs){
        try {
          final Object resultPojo=invokeMethodElseFromCache(targetAdapter,argumentAdapters);
          if (LOG.isDebugEnabled()) {
            LOG.debug(" action result " + resultPojo);
          }
          ObjectAdapter resultAdapter=cloneIfViewModelCloneable(resultPojo,targetAdapter);
          return resultAdapter != null ? resultAdapter.getObject() : null;
        }
 catch (        InvocationTargetException|IllegalAccessException e) {
          throw new RuntimeException(e);
        }
      }
    }
;
    interaction.execute(callable,actionArgs,getClockService());
    final Interaction.Execution priorExecution=interaction.getPriorExecution();
    final RuntimeException executionExceptionIfAny=priorExecution.getException();
    if (executionExceptionIfAny != null) {
      throw executionExceptionIfAny;
    }
    resultAdapter=getAdapterManager().adapterFor(priorExecution.getResult());
    setCommandResultIfEntity(command,resultAdapter);
    final PublishedActionFacet publishedActionFacet=getIdentified().getFacet(PublishedActionFacet.class);
    if (publishedActionFacet != null && currentInvocation.get() == null) {
      final CurrentInvocation currentInvocation1=new CurrentInvocation(targetAdapter,owningAction,getIdentified(),argumentAdapters,resultAdapter,command);
      currentInvocation.set(currentInvocation1);
    }
    publishAction();
  }
  return resultAdapter;
}
