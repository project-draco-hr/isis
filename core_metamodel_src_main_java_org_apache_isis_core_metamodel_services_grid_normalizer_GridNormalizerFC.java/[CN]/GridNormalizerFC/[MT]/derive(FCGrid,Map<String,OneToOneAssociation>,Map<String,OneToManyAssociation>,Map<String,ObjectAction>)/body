{
  final LinkedHashMap<String,PropertyLayoutData> propertyIds=metadata.getAllPropertiesById();
  final LinkedHashMap<String,CollectionLayoutData> collectionIds=metadata.getAllCollectionsById();
  final LinkedHashMap<String,ActionLayoutData> actionIds=metadata.getAllActionsById();
  final AtomicReference<FieldSet> defaultPropertyGroupRef=new AtomicReference<>();
  final AtomicReference<FCColumn> firstColumnRef=new AtomicReference<>();
  final AtomicReference<FCTabGroup> lastTabGroupRef=new AtomicReference<>();
  metadata.visit(new FCGrid.VisitorAdapter(){
    @Override public void visit(    final FCColumn fcColumn){
      firstColumnRef.compareAndSet(null,fcColumn);
    }
    @Override public void visit(    final FieldSet fieldSet){
      if (MemberGroupLayoutFacet.DEFAULT_GROUP.equals(fieldSet.getName())) {
        defaultPropertyGroupRef.compareAndSet(null,fieldSet);
      }
    }
    @Override public void visit(    final FCTabGroup fcTabGroup){
      lastTabGroupRef.set(fcTabGroup);
    }
  }
);
  final Tuple<List<String>> propertyIdTuple=surplusAndMissing(propertyIds.keySet(),oneToOneAssociationById.keySet());
  final List<String> surplusPropertyIds=propertyIdTuple.first;
  final List<String> missingPropertyIds=propertyIdTuple.second;
  for (  String surplusPropertyId : surplusPropertyIds) {
    propertyIds.get(surplusPropertyId).setMetadataError("No such property");
  }
  if (!missingPropertyIds.isEmpty()) {
    boolean wasSet=defaultPropertyGroupRef.compareAndSet(null,new FieldSet(MemberGroupLayoutFacet.DEFAULT_GROUP));
    final FieldSet defaultFieldSet=defaultPropertyGroupRef.get();
    if (wasSet) {
      firstColumnRef.get().getFieldSets().add(defaultFieldSet);
    }
    for (    final String propertyId : missingPropertyIds) {
      defaultFieldSet.getProperties().add(new PropertyLayoutData(propertyId));
    }
  }
  final Tuple<List<String>> collectionIdTuple=surplusAndMissing(collectionIds.keySet(),oneToManyAssociationById.keySet());
  final List<String> surplusCollectionIds=collectionIdTuple.first;
  final List<String> missingCollectionIds=collectionIdTuple.second;
  for (  String surplusCollectionId : surplusCollectionIds) {
    collectionIds.get(surplusCollectionId).setMetadataError("No such collection");
  }
  if (!missingCollectionIds.isEmpty()) {
    while (metadata.getTabGroups().size() < 2) {
      final FCTabGroup tabGroup=new FCTabGroup();
      metadata.getTabGroups().add(tabGroup);
      lastTabGroupRef.set(tabGroup);
    }
    final FCTabGroup lastTabGroup=lastTabGroupRef.get();
    for (    final String collectionId : missingCollectionIds) {
      final FCTab FCTab=new FCTab();
      lastTabGroup.getTabs().add(FCTab);
      FCColumn left=new FCColumn(12);
      FCTab.setLeft(left);
      final CollectionLayoutData layoutMetadata=new CollectionLayoutData(collectionId);
      layoutMetadata.setDefaultView("table");
      left.getCollections().add(layoutMetadata);
    }
  }
  final Tuple<List<String>> actionIdTuple=surplusAndMissing(actionIds.keySet(),objectActionById.keySet());
  final List<String> surplusActionIds=actionIdTuple.first;
  final List<String> missingActionIds=actionIdTuple.second;
  for (  String surplusActionId : surplusActionIds) {
    actionIds.get(surplusActionId).setMetadataError("No such action");
  }
  if (!missingActionIds.isEmpty()) {
    for (    String actionId : missingActionIds) {
      List<ActionLayoutData> actions=metadata.getActions();
      if (actions == null) {
        actions=Lists.newArrayList();
        metadata.setActions(actions);
      }
      actions.add(new ActionLayoutData(actionId));
    }
  }
}
