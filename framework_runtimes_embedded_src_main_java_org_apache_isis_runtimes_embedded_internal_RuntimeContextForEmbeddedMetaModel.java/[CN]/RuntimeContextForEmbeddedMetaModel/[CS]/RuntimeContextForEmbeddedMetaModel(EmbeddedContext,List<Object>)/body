{
  this.services=services;
  this.authenticationSessionProvider=new AuthenticationSessionProviderAbstract(){
    @Override public AuthenticationSession getAuthenticationSession(){
      return context.getAuthenticationSession();
    }
  }
;
  this.querySubmitter=new QuerySubmitterAbstract(){
    @Override public List<ObjectAdapter> allMatchingQuery(    final Query query){
      return wrap(context.allMatchingQuery(query));
    }
    @Override public <T>ObjectAdapter firstMatchingQuery(    final Query<T> query){
      return getAdapterMap().adapterFor(context.firstMatchingQuery(query));
    }
  }
;
  this.adapterMap=new AdapterMapAbstract(){
    @Override public ObjectAdapter adapterFor(    final Object domainObject){
      final ObjectSpecification domainObjectSpec=getSpecificationLookup().loadSpecification(domainObject.getClass());
      final PersistenceState persistenceState=context.getPersistenceState(domainObject);
      return new StandaloneAdapter(domainObjectSpec,domainObject,persistenceState);
    }
    @Override public ObjectAdapter adapterFor(    final Object domainObject,    final ObjectAdapter ownerAdapter){
      return adapterFor(domainObject);
    }
    @Override public ObjectAdapter adapterFor(    final Object domainObject,    final ObjectAdapter ownerAdapter,    final ObjectAssociation association){
      return adapterFor(domainObject);
    }
    @Override public ObjectAdapter getAdapterFor(    final Object domainObject){
      return adapterFor(domainObject);
    }
  }
;
  this.objectInstantiator=new ObjectInstantiatorAbstract(){
    @Override public Object instantiate(    final Class<?> type) throws ObjectInstantiationException {
      return context.instantiate(type);
    }
  }
;
  this.objectPersistor=new ObjectPersistorAbstract(){
    @Override public void makePersistent(    final ObjectAdapter adapter){
      context.makePersistent(adapter.getObject());
    }
    @Override public void remove(    final ObjectAdapter adapter){
      context.remove(adapter.getObject());
    }
  }
;
  this.objectDirtier=new ObjectDirtierAbstract(){
    @Override public void objectChanged(    final ObjectAdapter adapter){
      context.objectChanged(adapter.getObject());
    }
    @Override public void objectChanged(    final Object object){
      context.objectChanged(object);
    }
  }
;
  this.servicesProvider=new ServicesProviderAbstract(){
    @Override public List<ObjectAdapter> getServices(){
      return serviceAdapters;
    }
  }
;
  this.domainObjectServices=new DomainObjectServicesAbstract(){
    @Override public ObjectAdapter createTransientInstance(    final ObjectSpecification spec){
      final Object domainObject=spec.createObject();
      final ObjectAdapter adapter=adapterMap.adapterFor(domainObject);
      return spec.initialize(adapter);
    }
    @Override public ObjectAdapter createAggregatedInstance(    final ObjectSpecification spec,    final ObjectAdapter parent){
      throw new UnsupportedOperationException("Not yet supported by this implementation of RuntimeContext");
    }
    @Override public void resolve(    final Object parent){
      context.resolve(parent);
    }
    @Override public void resolve(    final Object parent,    final Object field){
      context.resolve(parent,field);
    }
    @Override public boolean flush(){
      return context.flush();
    }
    @Override public void commit(){
      context.commit();
    }
    @Override public String getProperty(    final String name){
      return RuntimeContextForEmbeddedMetaModel.this.getProperty(name);
    }
    @Override public List<String> getPropertyNames(){
      return RuntimeContextForEmbeddedMetaModel.this.getPropertyNames();
    }
    @Override public void informUser(    final String message){
      context.informUser(message);
    }
    @Override public void warnUser(    final String message){
      context.warnUser(message);
    }
    @Override public void raiseError(    final String message){
      context.raiseError(message);
    }
  }
;
  this.localizationProvider=new LocalizationProviderAbstract(){
    @Override public Localization getLocalization(){
      return context.getLocalization();
    }
  }
;
  this.dependencyInjector=new DependencyInjectorAbstract(){
    @Override public void injectDependenciesInto(    final Object domainObject){
      if (servicesInjector == null) {
        throw new IllegalStateException("must setContainer before using this method");
      }
      servicesInjector.injectDependencies(domainObject);
    }
  }
;
}
