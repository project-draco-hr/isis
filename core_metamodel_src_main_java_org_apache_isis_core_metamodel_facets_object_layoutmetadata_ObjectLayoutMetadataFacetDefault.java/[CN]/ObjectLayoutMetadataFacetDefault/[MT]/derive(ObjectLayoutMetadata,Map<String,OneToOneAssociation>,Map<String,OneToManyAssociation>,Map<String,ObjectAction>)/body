{
  final LinkedHashMap<String,PropertyLayoutMetadata> propertyIds=metadata.getAllPropertiesById();
  final LinkedHashMap<String,CollectionLayoutMetadata> collectionIds=metadata.getAllCollectionsById();
  final LinkedHashMap<String,ActionLayoutMetadata> actionIds=metadata.getAllActionsById();
  final AtomicReference<PropertyGroupMetadata> defaultPropertyGroupRef=new AtomicReference<>();
  final AtomicReference<ColumnMetadata> firstColumnRef=new AtomicReference<>();
  final AtomicReference<TabGroupMetadata> lastTabGroupRef=new AtomicReference<>();
  metadata.visit(new ObjectLayoutMetadata.VisitorAdapter(){
    @Override public void visit(    final ColumnMetadata columnMetadata){
      firstColumnRef.compareAndSet(null,columnMetadata);
    }
    @Override public void visit(    final PropertyGroupMetadata propertyGroupMetadata){
      if (MemberGroupLayoutFacet.DEFAULT_GROUP.equals(propertyGroupMetadata.getName())) {
        defaultPropertyGroupRef.compareAndSet(null,propertyGroupMetadata);
      }
    }
    @Override public void visit(    final TabGroupMetadata tabGroup){
      lastTabGroupRef.set(tabGroup);
    }
  }
);
  final Tuple<List<String>> propertyIdTuple=surplusAndMissing(propertyIds.keySet(),oneToOneAssociationById.keySet());
  final List<String> surplusPropertyIds=propertyIdTuple.first;
  final List<String> missingPropertyIds=propertyIdTuple.second;
  for (  String surplusPropertyId : surplusPropertyIds) {
    propertyIds.get(surplusPropertyId).setMetadataError("No such property");
  }
  if (!missingPropertyIds.isEmpty()) {
    boolean wasSet=defaultPropertyGroupRef.compareAndSet(null,new PropertyGroupMetadata(MemberGroupLayoutFacet.DEFAULT_GROUP));
    final PropertyGroupMetadata defaultPropertyGroupMetadata=defaultPropertyGroupRef.get();
    if (wasSet) {
      firstColumnRef.get().getPropertyGroups().add(defaultPropertyGroupMetadata);
    }
    for (    final String propertyId : missingPropertyIds) {
      defaultPropertyGroupMetadata.getProperties().add(new PropertyLayoutMetadata(propertyId));
    }
  }
  final Tuple<List<String>> collectionIdTuple=surplusAndMissing(collectionIds.keySet(),oneToManyAssociationById.keySet());
  final List<String> surplusCollectionIds=collectionIdTuple.first;
  final List<String> missingCollectionIds=collectionIdTuple.second;
  for (  String surplusCollectionId : surplusCollectionIds) {
    collectionIds.get(surplusCollectionId).setMetadataError("No such collection");
  }
  if (!missingCollectionIds.isEmpty()) {
    while (metadata.getTabGroups().size() < 2) {
      final TabGroupMetadata tabGroup=new TabGroupMetadata();
      metadata.getTabGroups().add(tabGroup);
      lastTabGroupRef.set(tabGroup);
    }
    final TabGroupMetadata lastTabGroup=lastTabGroupRef.get();
    for (    final String collectionId : missingCollectionIds) {
      final TabMetadata tabMetadata=new TabMetadata();
      lastTabGroup.getTabs().add(tabMetadata);
      ColumnMetadata left=new ColumnMetadata(12);
      tabMetadata.setLeft(left);
      final CollectionLayoutMetadata layoutMetadata=new CollectionLayoutMetadata(collectionId);
      layoutMetadata.setDefaultView("table");
      left.getCollections().add(layoutMetadata);
    }
  }
  final Tuple<List<String>> actionIdTuple=surplusAndMissing(actionIds.keySet(),objectActionById.keySet());
  final List<String> surplusActionIds=actionIdTuple.first;
  final List<String> missingActionIds=actionIdTuple.second;
  for (  String surplusActionId : surplusActionIds) {
    actionIds.get(surplusActionId).setMetadataError("No such action");
  }
  if (!missingActionIds.isEmpty()) {
    for (    String actionId : missingActionIds) {
      List<ActionLayoutMetadata> actions=metadata.getActions();
      if (actions == null) {
        actions=Lists.newArrayList();
        metadata.setActions(actions);
      }
      actions.add(new ActionLayoutMetadata(actionId));
    }
  }
  metadata.visit(new ObjectLayoutMetadata.Visitor(){
    private final Map<String,AtomicInteger> sequenceByPath=Maps.newHashMap();
    @Override public void visit(    final ObjectLayoutMetadata objectLayoutMetadata){
      objectLayoutMetadata.setPath("/layout");
    }
    @Override public void visit(    final TabGroupMetadata tabGroup){
      tabGroup.setPath(pathFor(tabGroup,"tabGroup"));
    }
    @Override public void visit(    final TabMetadata tabMetadata){
      tabMetadata.setPath(pathFor(tabMetadata,"tab"));
    }
    @Override public void visit(    final ColumnMetadata columnMetadata){
      columnMetadata.setPath(pathFor(columnMetadata,"column"));
    }
    @Override public void visit(    final PropertyGroupMetadata propertyGroupMetadata){
      propertyGroupMetadata.setPath(pathFor(propertyGroupMetadata,"propertyGroup"));
    }
    @Override public void visit(    final PropertyLayoutMetadata propertyLayoutMetadata){
      propertyLayoutMetadata.setPath(pathFor(propertyLayoutMetadata,"property"));
    }
    @Override public void visit(    final CollectionLayoutMetadata collectionLayoutMetadata){
      collectionLayoutMetadata.setPath(pathFor(collectionLayoutMetadata,"collection"));
    }
    @Override public void visit(    final ActionLayoutMetadata actionLayoutMetadata){
      actionLayoutMetadata.setPath(pathFor(actionLayoutMetadata,"action"));
    }
    private String pathFor(    final Owned<?> owned,    final String type){
      final String ownerPath=owned.getOwner().getPath();
      final String prefix=ownerPath + "/" + type;
      AtomicInteger atomicInteger=sequenceByPath.get(prefix);
      if (atomicInteger == null) {
        atomicInteger=new AtomicInteger(-1);
        sequenceByPath.put(prefix,atomicInteger);
      }
      final int seq=atomicInteger.incrementAndGet();
      return prefix + seq;
    }
  }
);
}
