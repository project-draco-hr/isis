{
  final LinkedHashMap<String,PropertyLayoutMetadata> propertyIds=metadata.getAllPropertiesById();
  final LinkedHashMap<String,CollectionLayoutMetadata> collectionIds=metadata.getAllCollectionsById();
  final LinkedHashMap<String,ActionLayoutMetadata> actionIds=metadata.getAllActionsById();
  final AtomicReference<PropertyGroup> defaultPropertyGroupRef=new AtomicReference<>();
  final AtomicReference<Column> firstColumnRef=new AtomicReference<>();
  final AtomicReference<TabGroup> lastTabGroupRef=new AtomicReference<>();
  metadata.visit(new ObjectLayoutMetadata.VisitorAdapter(){
    @Override public void visit(    final Column column){
      firstColumnRef.compareAndSet(null,column);
    }
    @Override public void visit(    final PropertyGroup propertyGroup){
      if (MemberGroupLayoutFacet.DEFAULT_GROUP.equals(propertyGroup.getName())) {
        defaultPropertyGroupRef.compareAndSet(null,propertyGroup);
      }
    }
    @Override public void visit(    final TabGroup tabGroup){
      lastTabGroupRef.set(tabGroup);
    }
  }
);
  final Tuple<List<String>> propertyIdTuple=surplusAndMissing(propertyIds.keySet(),oneToOneAssociationById.keySet());
  final List<String> surplusPropertyIds=propertyIdTuple.first;
  final List<String> missingPropertyIds=propertyIdTuple.second;
  for (  String surplusPropertyId : surplusPropertyIds) {
    propertyIds.get(surplusPropertyId).setMetadataError("No such property");
  }
  if (!missingPropertyIds.isEmpty()) {
    boolean wasSet=defaultPropertyGroupRef.compareAndSet(null,new PropertyGroup(MemberGroupLayoutFacet.DEFAULT_GROUP));
    final PropertyGroup defaultPropertyGroup=defaultPropertyGroupRef.get();
    if (wasSet) {
      firstColumnRef.get().getPropertyGroups().add(defaultPropertyGroup);
    }
    for (    final String propertyId : missingPropertyIds) {
      defaultPropertyGroup.getProperties().add(new PropertyLayoutMetadata(propertyId));
    }
  }
  final Tuple<List<String>> collectionIdTuple=surplusAndMissing(collectionIds.keySet(),oneToManyAssociationById.keySet());
  final List<String> surplusCollectionIds=collectionIdTuple.first;
  final List<String> missingCollectionIds=collectionIdTuple.second;
  for (  String surplusCollectionId : surplusCollectionIds) {
    collectionIds.get(surplusCollectionId).setMetadataError("No such collection");
  }
  if (!missingCollectionIds.isEmpty()) {
    while (metadata.getTabGroups().size() < 2) {
      final TabGroup tabGroup=new TabGroup();
      metadata.getTabGroups().add(tabGroup);
      lastTabGroupRef.set(tabGroup);
    }
    final TabGroup lastTabGroup=lastTabGroupRef.get();
    for (    final String collectionId : missingCollectionIds) {
      final Tab tab=new Tab();
      lastTabGroup.getTabs().add(tab);
      Column left=new Column(12);
      tab.setLeft(left);
      final CollectionLayoutMetadata layoutMetadata=new CollectionLayoutMetadata(collectionId);
      layoutMetadata.setDefaultView("table");
      left.getCollections().add(layoutMetadata);
    }
  }
  final Tuple<List<String>> actionIdTuple=surplusAndMissing(actionIds.keySet(),objectActionById.keySet());
  final List<String> surplusActionIds=actionIdTuple.first;
  final List<String> missingActionIds=actionIdTuple.second;
  for (  String surplusActionId : surplusActionIds) {
    actionIds.get(surplusActionId).setMetadataError("No such action");
  }
  if (!missingActionIds.isEmpty()) {
    for (    String actionId : missingActionIds) {
      List<ActionLayoutMetadata> actions=metadata.getActions();
      if (actions == null) {
        actions=Lists.newArrayList();
        metadata.setActions(actions);
      }
      actions.add(new ActionLayoutMetadata(actionId));
    }
  }
}
