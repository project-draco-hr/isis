{
  return new Statement(){
    @Override public void evaluate() throws Throwable {
      base.evaluate();
      verifyMocks();
    }
    private void verifyMocks(){
      final Mockery context=contextToVerifyIfAny();
      if (context != null) {
        context.assertIsSatisfied();
      }
 else {
        throw new AssertionError("could not locate JMock context");
      }
    }
    private Mockery contextToVerifyIfAny(){
      final Mockery context=JMockRule.this.context;
      if (context != null) {
        return context;
      }
      return findContextReflectivelyIfAny();
    }
    private Mockery findContextReflectivelyIfAny(){
      Class<?> clsToSearch=method.getMethod().getDeclaringClass();
      do {
        final Mockery mockery=findContextIfAny(clsToSearch,target);
        if (mockery != null) {
          return mockery;
        }
        clsToSearch=clsToSearch.getSuperclass();
      }
 while (clsToSearch != Object.class);
      return null;
    }
    private Mockery findContextIfAny(    final Class<?> cls,    final Object target){
      final Field[] fields=cls.getDeclaredFields();
      for (      final Field field : fields) {
        final Class<?> type=field.getType();
        if (Mockery.class.isAssignableFrom(type)) {
          try {
            field.setAccessible(true);
            return (Mockery)field.get(target);
          }
 catch (          final IllegalArgumentException e) {
            continue;
          }
catch (          final IllegalAccessException e) {
            continue;
          }
        }
      }
      return null;
    }
  }
;
}
