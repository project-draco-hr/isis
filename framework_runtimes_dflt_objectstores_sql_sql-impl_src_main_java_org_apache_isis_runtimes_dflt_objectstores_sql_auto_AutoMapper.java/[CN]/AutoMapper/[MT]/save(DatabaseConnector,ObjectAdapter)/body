{
  final SerialNumberVersion version=(SerialNumberVersion)object.getVersion();
  final long nextSequence;
  if (useVersioning) {
    nextSequence=version.getSequence() + 1;
  }
 else {
    nextSequence=version.getSequence();
  }
  final StringBuffer sql=new StringBuffer();
  sql.append("UPDATE " + table + " SET ");
  for (  final FieldMapping mapping : fieldMappings) {
    mapping.appendUpdateValues(connector,sql,object);
    sql.append(", ");
  }
  sql.append(versionMapping.updateAssigment(connector,nextSequence));
  sql.append(", ");
  titleMapping.appendUpdateAssignment(connector,sql,object);
  sql.append(" WHERE ");
  idMapping.appendWhereClause(connector,sql,object.getOid());
  if (useVersioning) {
    sql.append(" AND ");
    sql.append(versionMapping.whereClause(connector,(SerialNumberVersion)object.getVersion()));
  }
  final int updateCount=connector.update(sql.toString());
  if (updateCount == 0) {
    LOG.info("concurrency conflict object " + this + "; no update performed");
    throw new ConcurrencyException("",object.getOid());
  }
 else {
    object.setOptimisticLock(createVersion(nextSequence));
  }
  for (  final CollectionMapper collectionMapper : collectionMappers) {
    collectionMapper.saveInternalCollection(connector,object);
  }
}
