{
  NakedObjectField field=fieldAccessorFor(fieldName);
  assertFieldVisible(field);
  assertFieldModifiable(fieldName,field);
  TestNaked targetField=getField(fieldName);
  if (targetField instanceof TestValue) {
    throw new IllegalActionError("drop(..) not allowed on value target field; use fieldEntry(..) instead");
  }
  if ((targetField.getForNaked() != null) && !(targetField.getForNaked() instanceof InternalCollection)) {
    throw new IllegalActionError("Field already contains an object: " + targetField.getForNaked());
  }
  NakedObjectAssociation association=(NakedObjectAssociation)fieldAccessorFor(fieldName);
  NakedObject obj=(NakedObject)object.getForNaked();
  if (association.getSpecification() != null && !obj.getSpecification().isOfType(association.getSpecification())) {
    throw new IllegalActionError("Can't drop a " + object.getForNaked().getSpecification().getShortName() + " on to the "+ fieldName+ " field (which accepts "+ association.getSpecification()+ ")");
  }
  NakedObject nakedObject=(NakedObject)getForNaked();
  Hint about;
  if (association instanceof OneToOneAssociation) {
    assertEmpty(fieldName);
    about=nakedObject.getHint(association,obj);
  }
 else   if (association instanceof OneToManyAssociation) {
    about=((OneToManyAssociation)association).getHint(nakedObject,obj,true);
  }
 else {
    throw new NakedObjectRuntimeException();
  }
  if (about.canAccess().isVetoed()) {
    throw new IllegalActionError("Cannot access the field " + field);
  }
  if (about.canUse().isVetoed()) {
    throw new IllegalActionError("Cannot associate " + obj + " in the field "+ field+ " within "+ nakedObject+ ": "+ about.canUse().getReason());
  }
  nakedObject.setAssociation(association,obj);
}
