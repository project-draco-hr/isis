{
  ensureThatState(getState().canCommit(),is(true),"state is: " + getState());
  ensureThatState(abortCause,is(nullValue()),"cannot commit: an abort cause has been set");
  if (LOG.isDebugEnabled()) {
    LOG.debug("preCommit transaction " + this);
  }
  if (getState() == State.COMMITTED) {
    if (LOG.isInfoEnabled()) {
      LOG.info("already committed; ignoring");
    }
    return;
  }
  try {
    final Map<AdapterAndProperty,PreAndPostValues> processedObjectProperties=Maps.newLinkedHashMap();
    while (!changedObjectProperties.isEmpty()) {
      final Set<AdapterAndProperty> keys=Sets.newLinkedHashSet(changedObjectProperties.keySet());
      for (      final AdapterAndProperty aap : keys) {
        final PreAndPostValues papv=changedObjectProperties.remove(aap);
        final ObjectAdapter adapter=aap.getAdapter();
        if (adapter.isDestroyed()) {
          papv.setPost(Placeholder.DELETED);
        }
 else {
          papv.setPost(aap.getPropertyValue());
        }
        processedObjectProperties.put(aap,papv);
      }
    }
    final Set<Entry<AdapterAndProperty,PreAndPostValues>> changedObjectProperties=Collections.unmodifiableSet(Sets.filter(processedObjectProperties.entrySet(),PreAndPostValues.Predicates.CHANGED));
    ensureCommandsPersistedIfDirtyXactnAndAnySafeSemanticsHonoured(changedObjectProperties);
    preCommitServices(changedObjectProperties);
  }
 catch (  final RuntimeException ex) {
    setAbortCause(new IsisTransactionManagerException(ex));
    clearCommandServiceIfConfigured();
    throw ex;
  }
}
