{
  try {
    final CRC32 crc32=new CRC32();
    final DataOutput output=new DataOutputStream(connection.getOutputStream());
    final DataInput input=new DataInputStream(new CheckedInputStream(connection.getInputStream(),crc32));
    if (input.readByte() != INIT) {
      return;
    }
    final LogRange logFileRange=Util.logFileRange();
    final long lastId=logFileRange.noLogFile() ? -1 : logFileRange.getLast();
    output.writeLong(lastId);
    do {
      if (input.readByte() != RECOVERY_LOG) {
        return;
      }
      crc32.reset();
      final long logId=input.readLong();
      final File file=Util.tmpLogFile(logId);
      LOG.info("syncing recovery file: " + file.getName());
      final BufferedOutputStream fileOutput=new BufferedOutputStream(new FileOutputStream(file));
      final byte[] buffer=new byte[8092];
      int length;
      while ((length=input.readInt()) > 0) {
        input.readFully(buffer,0,length);
        fileOutput.write(buffer,0,length);
      }
      fileOutput.close();
      final long calculatedChecksum=crc32.getValue();
      final long sentChecksum=input.readLong();
      if (calculatedChecksum != sentChecksum) {
        throw new NoSqlStoreException("Checksum didn't match during download of " + file.getName());
      }
      recover(file);
      final File renameTo=Util.logFile(logId);
      file.renameTo(renameTo);
    }
 while (true);
  }
 catch (  final NoSqlStoreException e) {
    LOG.error("file server failure",e);
  }
catch (  final IOException e) {
    LOG.error("networking failure",e);
  }
catch (  final RuntimeException e) {
    LOG.error("request failure",e);
  }
 finally {
    try {
      connection.close();
    }
 catch (    final IOException e) {
      LOG.warn("failure to close connection",e);
    }
  }
}
