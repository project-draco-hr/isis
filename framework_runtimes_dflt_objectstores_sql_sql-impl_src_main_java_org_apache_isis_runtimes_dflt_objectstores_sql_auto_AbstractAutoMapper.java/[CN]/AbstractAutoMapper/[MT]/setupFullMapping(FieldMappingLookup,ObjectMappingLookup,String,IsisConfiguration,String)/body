{
  fields.addAll(specification.getAssociations());
  if (specification.hasSubclasses()) {
    getExtraFields(fields);
    final List<ObjectSpecification> subclasses=specification.subclasses();
    for (    ObjectSpecification subclass : subclasses) {
      final List<? extends ObjectAssociation> subAssociations=subclass.getAssociations();
      for (      ObjectAssociation subA : subAssociations) {
        boolean found=false;
        String name=subA.getName();
        for (        ObjectAssociation existingField : fields) {
          if (existingField.getName().equals(name)) {
            found=true;
            continue;
          }
        }
        if (found == false) {
          fields.add(subA);
        }
      }
    }
  }
  int simpleFieldCount=0;
  int collectionFieldCount=0;
  for (int i=0; i < fields.size(); i++) {
    if (fields.get(i).isNotPersisted()) {
      continue;
    }
 else     if (fields.get(i).isOneToManyAssociation()) {
      collectionFieldCount++;
    }
 else {
      simpleFieldCount++;
    }
  }
  final ObjectAssociation[] oneToOneProperties=new ObjectAssociation[simpleFieldCount];
  final ObjectAssociation[] oneToManyProperties=new ObjectAssociation[collectionFieldCount];
  collectionMappers=new CollectionMapper[collectionFieldCount];
  collectionMapperFields=new String[collectionFieldCount];
  final IsisConfiguration subset=IsisContext.getConfiguration().createSubset(parameterBase + ".mapper.");
  for (int i=0, simpleFieldNo=0, collectionFieldNo=0; i < fields.size(); i++) {
    final ObjectAssociation field=fields.get(i);
    if (field.isNotPersisted()) {
      continue;
    }
 else     if (field.isOneToManyAssociation()) {
      oneToManyProperties[collectionFieldNo]=field;
      final String type=subset.getString(field.getId());
      if (type == null || type.equals("association-table")) {
        CollectionMapper collectionMapper=null;
        if (this instanceof MultiColumnCombinedCollectionMapper) {
          MultiColumnCombinedCollectionMapper mc=(MultiColumnCombinedCollectionMapper)this;
          if (mc.priorField == field) {
            collectionMapper=mc;
          }
        }
        if (collectionMapper == null) {
          collectionMapper=new MultiColumnCombinedCollectionMapper(oneToManyProperties[collectionFieldNo],parameterBase,lookup,objectMapperLookup,this,field);
        }
        collectionMappers[collectionFieldNo]=collectionMapper;
        collectionMapperFields[collectionFieldNo]=field.getId();
      }
 else       if (type.equals("fk-table")) {
        final String property=parameterBase + field.getId() + ".element-type";
        final String elementType=configParameters.getString(property);
        if (elementType == null) {
          throw new SqlObjectStoreException("Expected property " + property);
        }
      }
 else {
        throw new NotYetImplementedException("for " + type);
      }
      collectionFieldNo++;
    }
 else     if (field.isOneToOneAssociation()) {
      oneToOneProperties[simpleFieldNo]=field;
      simpleFieldNo++;
    }
 else {
      oneToOneProperties[simpleFieldNo]=field;
      simpleFieldNo++;
    }
  }
  for (  final ObjectAssociation field : oneToOneProperties) {
    final FieldMapping mapping=lookup.createMapping(field);
    fieldMappings.add(mapping);
    fieldMappingLookup.put(field,mapping);
  }
}
